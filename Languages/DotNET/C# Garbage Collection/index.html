<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>C# Garbage Collection - KaiDocs</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "C# Garbage Collection", url: "#_top", children: [
              {title: "Fundamentals of memory", url: "#fundamentals-of-memory" },
              {title: "Conditions for a garbage collection", url: "#conditions-for-a-garbage-collection" },
              {title: "The managed heap", url: "#the-managed-heap" },
              {title: "Generations", url: "#generations" },
              {title: "What happens during a garbage collection", url: "#what-happens-during-a-garbage-collection" },
              {title: "Manipulating unmanaged resources", url: "#manipulating-unmanaged-resources" },
              {title: "Workstation and server garbage collection", url: "#workstation-and-server-garbage-collection" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../C%23%20MultiThread%20-%20BW%E6%80%92%E6%9F%8F%E6%96%87%E4%BB%B6/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../C%23%20MultiThread%20-%20BW%E6%80%92%E6%9F%8F%E6%96%87%E4%BB%B6/" class="btn btn-xs btn-link">
        C# MultiThread - BW怒柏文件
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../C%20sharp/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../C%20sharp/" class="btn btn-xs btn-link">
        C Sharp
      </a>
    </div>
    
  </div>

    

    <h1 id="c-garbage-collection">C# Garbage Collection</h1>
<h2 id="fundamentals-of-memory">Fundamentals of memory</h2>
<ul>
<li>Each process has its own, separate virtual address space. All processes on the same computer share the same physical memory, and share the page file if there is one.</li>
<li>As an application developer, you work only with virtual address space and never manipulate physical memory directly. The garbage collector allocates and frees virtual memory for you on the managed heap.</li>
<li>Virtual memory can be in three states:</li>
<li>Free. The block of memory has no references to it and is available for allocation.</li>
<li>Reserved. The block of memory is available for your use and cannot be used for any other allocation request. However, you cannot store data to this memory block until it is committed.</li>
<li>Committed. The block of memory is assigned to physical storage.</li>
<li>Virtual address space can get fragmented. This means that there are free blocks, also known as holes, in the address space.</li>
<li>You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</li>
</ul>
<h2 id="conditions-for-a-garbage-collection">Conditions for a garbage collection</h2>
<ul>
<li>The system has low physical memory. This is detected by either the low memory notification from the OS or low memory indicated by the host.</li>
<li>The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold. This threshold is continuously adjusted as the process runs.</li>
<li>The GC.Collect method is called. In almost all cases, you do not have to call this method, because the garbage collector runs continuously. This method is primarily used for unique situations and testing.</li>
</ul>
<h2 id="the-managed-heap">The managed heap</h2>
<p>There is a managed heap for each managed process. All threads in the process allocate memory for objects on the same heap.</p>
<blockquote>
<p><strong>Important</strong>
The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates. Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</p>
</blockquote>
<p>回收大小跟頻率都是動態調整</p>
<blockquote>
<p>The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</p>
</blockquote>
<h2 id="generations">Generations</h2>
<ul>
<li>
<p><strong>Generation 0</strong>. This is the youngest generation and contains short-lived objects. An example of a short-lived object is a temporary variable. Garbage collection occurs most frequently in this generation.<br>
Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.<br>
Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</p>
</li>
<li>
<p><strong>Generation 1</strong>. This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</p>
</li>
<li>
<p><strong>Generation 2</strong>. This generation contains long-lived objects. An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</p>
</li>
</ul>
<p>Garbage collections occur on specific generations as conditions warrant. Collecting a generation means collecting objects in that generation and all its younger generations. A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</p>
<h3 id="survival-and-promotions">Survival and promotions</h3>
<ul>
<li>Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</li>
<li>When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory. The CLR continually balances two priorities: not letting an application's working set get too big and not letting the garbage collection take too much time.</li>
</ul>
<h3 id="ephemeral-generations-and-segments">Ephemeral generations and segments</h3>
<p>Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</p>
<p>Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment. Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection. The old ephemeral segment becomes the new generation 2 segment.</p>
<h2 id="what-happens-during-a-garbage-collection">What happens during a garbage collection</h2>
<p>A garbage collection has the following phases:</p>
<ul>
<li>A marking phase that finds and creates a list of all live objects.</li>
<li>A relocating phase that updates the references to the objects that will be compacted.</li>
<li>A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects. The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</li>
</ul>
<p>The garbage collector uses the following information to determine whether objects are live:</p>
<ul>
<li><strong>Stack roots</strong>. Stack variables provided by the just-in-time (JIT) compiler and stack walker. Note that JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</li>
<li><strong>Garbage collection handles</strong>. Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</li>
<li><strong>Static data</strong>. Static objects in application domains that could be referencing other objects. Each application domain keeps track of its static objects.</li>
</ul>
<blockquote>
<p>Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</p>
</blockquote>
<p>所有的managed threads在等待觸發GC的thread完成GC前會suspended</p>
<h2 id="manipulating-unmanaged-resources">Manipulating unmanaged resources</h2>
<p>When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation. Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</p>
<p>Finalize就當成一般GC物件，需要等待GC觸發，你也可以用Dispose就等於手動觸發。</p>
<h2 id="workstation-and-server-garbage-collection">Workstation and server garbage collection</h2>
<p>靠北如果覺得GC自己tune的不好你還可以塞configuration file setting給他...</p>
<p>後面感覺對碼農幫助不大，不想看了...</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../C%23%20MultiThread%20-%20BW%E6%80%92%E6%9F%8F%E6%96%87%E4%BB%B6/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../C%23%20MultiThread%20-%20BW%E6%80%92%E6%9F%8F%E6%96%87%E4%BB%B6/" class="btn btn-xs btn-link">
        C# MultiThread - BW怒柏文件
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../C%20sharp/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../C%20sharp/" class="btn btn-xs btn-link">
        C Sharp
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>